/**
 * Check whether the particular package is present on the device under test.
 *
 * @this {import('../adb.js').ADB}
 * @param {string} pkg - The name of the package to check.
 * @param {import('./types').IsAppInstalledOptions} [opts={}]
 * @return {Promise<boolean>} True if the package is installed.
 */
export function isAppInstalled(this: import("../adb.js").ADB, pkg: string, opts?: import("./types").IsAppInstalledOptions): Promise<boolean>;
/**
 * Start the particular URI on the device under test.
 *
 * @this {import('../adb.js').ADB}
 * @param {string} uri - The name of URI to start.
 * @param {string?} [pkg=null] - The name of the package to start the URI with.
 * @param {import('./types').StartUriOptions} [opts={}]
 */
export function startUri(this: import("../adb.js").ADB, uri: string, pkg?: string | null, opts?: import("./types").StartUriOptions): Promise<void>;
/**
 * Start the particular package/activity on the device under test.
 *
 * @this {import('../adb.js').ADB}
 * @param {import('./types').StartAppOptions} startAppOptions - Startup options mapping.
 * @return {Promise<string>} The output of the corresponding adb command.
 * @throws {Error} If there is an error while executing the activity
 */
export function startApp(this: import("../adb.js").ADB, startAppOptions: import("./types").StartAppOptions): Promise<string>;
/**
 * Helper method to call `adb dumpsys window windows/displays`
 * @this {import('../adb.js').ADB}
 * @returns {Promise<string>}
 */
export function dumpWindows(this: import("../adb.js").ADB): Promise<string>;
/**
 * Get the name of currently focused package and activity.
 *
 * @this {import('../adb.js').ADB}
 * @return {Promise<import('./types').PackageActivityInfo>}
 * @throws {Error} If there is an error while parsing the data.
 */
export function getFocusedPackageAndActivity(this: import("../adb.js").ADB): Promise<import("./types").PackageActivityInfo>;
/**
 * Wait for the given activity to be focused/non-focused.
 *
 * @this {import('../adb.js').ADB}
 * @param {string} pkg - The name of the package to wait for.
 * @param {string} activity - The name of the activity, belonging to that package,
 *                            to wait for.
 * @param {boolean} waitForStop - Whether to wait until the activity is focused (true)
 *                                or is not focused (false).
 * @param {number} [waitMs=20000] - Number of milliseconds to wait before timeout occurs.
 * @throws {error} If timeout happens.
 */
export function waitForActivityOrNot(this: import("../adb.js").ADB, pkg: string, activity: string, waitForStop: boolean, waitMs?: number): Promise<void>;
/**
 * Wait for the given activity to be focused
 *
 * @this {import('../adb.js').ADB}
 * @param {string} pkg - The name of the package to wait for.
 * @param {string} act - The name of the activity, belonging to that package,
 *                            to wait for.
 * @param {number} [waitMs=20000] - Number of milliseconds to wait before timeout occurs.
 * @throws {error} If timeout happens.
 */
export function waitForActivity(this: import("../adb.js").ADB, pkg: string, act: string, waitMs?: number): Promise<void>;
/**
 * Wait for the given activity to be non-focused.
 *
 * @this {import('../adb.js').ADB}
 * @param {string} pkg - The name of the package to wait for.
 * @param {string} act - The name of the activity, belonging to that package,
 *                            to wait for.
 * @param {number} [waitMs=20000] - Number of milliseconds to wait before timeout occurs.
 * @throws {error} If timeout happens.
 */
export function waitForNotActivity(this: import("../adb.js").ADB, pkg: string, act: string, waitMs?: number): Promise<void>;
/**
 * Uninstall the given package from the device under test.
 *
 * @this {import('../adb.js').ADB}
 * @param {string} pkg - The name of the package to be uninstalled.
 * @param {import('./types').UninstallOptions} [options={}] - The set of uninstall options.
 * @return {Promise<boolean>} True if the package was found on the device and
 *                   successfully uninstalled.
 */
export function uninstallApk(this: import("../adb.js").ADB, pkg: string, options?: import("./types").UninstallOptions): Promise<boolean>;
/**
 * Install the package after it was pushed to the device under test.
 *
 * @this {import('../adb.js').ADB}
 * @param {string} apkPathOnDevice - The full path to the package on the device file system.
 * @param {import('./types').ShellExecOptions} [opts={}] Additional exec options.
 * @throws {error} If there was a failure during application install.
 */
export function installFromDevicePath(this: import("../adb.js").ADB, apkPathOnDevice: string, opts?: import("./types").ShellExecOptions): Promise<void>;
/**
 * Caches the given APK at a remote location to speed up further APK deployments.
 *
 * @this {import('../adb.js').ADB}
 * @param {string} apkPath - Full path to the apk on the local FS
 * @param {import('./types').CachingOptions} [options={}] - Caching options
 * @returns {Promise<string>} - Full path to the cached apk on the remote file system
 * @throws {Error} if there was a failure while caching the app
 */
export function cacheApk(this: import("../adb.js").ADB, apkPath: string, options?: import("./types").CachingOptions): Promise<string>;
export class cacheApk {
    /**
     * Caches the given APK at a remote location to speed up further APK deployments.
     *
     * @this {import('../adb.js').ADB}
     * @param {string} apkPath - Full path to the apk on the local FS
     * @param {import('./types').CachingOptions} [options={}] - Caching options
     * @returns {Promise<string>} - Full path to the cached apk on the remote file system
     * @throws {Error} if there was a failure while caching the app
     */
    constructor(this: import("../adb.js").ADB, apkPath: string, options?: import("./types").CachingOptions);
    _areExtendedLsOptionsSupported: boolean | undefined;
    remoteAppsCache: LRUCache<string, string, unknown>;
}
/**
 * Install the package from the local file system.
 *
 * @this {import('../adb.js').ADB}
 * @param {string} appPath - The full path to the local package.
 * @param {import('./types').InstallOptions} [options={}] - The set of installation options.
 * @throws {Error} If an unexpected error happens during install.
 */
export function install(this: import("../adb.js").ADB, appPath: string, options?: import("./types").InstallOptions): Promise<void>;
/**
 * Retrieves the current installation state of the particular application
 *
 * @this {import('../adb.js').ADB}
 * @param {string} appPath - Full path to the application
 * @param {string?} [pkg=null] - Package identifier. If omitted then the script will
 * try to extract it on its own
 * @returns {Promise<import('./types').InstallState>} One of `APP_INSTALL_STATE` constants
 */
export function getApplicationInstallState(this: import("../adb.js").ADB, appPath: string, pkg?: string | null): Promise<import("./types").InstallState>;
/**
 * Install the package from the local file system or upgrade it if an older
 * version of the same package is already installed.
 *
 * @this {import('../adb.js').ADB}
 * @param {string} appPath - The full path to the local package.
 * @param {string?} [pkg=null] - The name of the installed package. The method will
 * perform faster if it is set.
 * @param {import('./types').InstallOrUpgradeOptions} [options={}] - Set of install options.
 * @throws {Error} If an unexpected error happens during install.
 * @returns {Promise<import('./types').InstallOrUpgradeResult>}
 */
export function installOrUpgrade(this: import("../adb.js").ADB, appPath: string, pkg?: string | null, options?: import("./types").InstallOrUpgradeOptions): Promise<import("./types").InstallOrUpgradeResult>;
/**
 * Extract string resources from the given package on local file system.
 *
 * @this {import('../adb.js').ADB}
 * @param {string} appPath - The full path to the .apk(s) package.
 * @param {string?} [language=null] - The name of the language to extract the resources for.
 * The default language is used if this equals to `null`
 * @param {string?} [outRoot=null] - The name of the destination folder on the local file system to
 * store the extracted file to. If not provided then the `localPath` property in the returned object
 * will be undefined.
 * @return {Promise<import('./types').ApkStrings>}
 */
export function extractStringsFromApk(this: import("../adb.js").ADB, appPath: string, language?: string | null, outRoot?: string | null): Promise<import("./types").ApkStrings>;
/**
 * Get the package info from local apk file.
 *
 * @this {import('../adb.js').ADB}
 * @param {string} appPath - The full path to existing .apk(s) package on the local
 *                           file system.
 * @return {Promise<import('./types').AppInfo|{}>} The parsed application information.
 */
export function getApkInfo(this: import("../adb.js").ADB, appPath: string): Promise<import("./types").AppInfo | {}>;
/**
 * Get the package info from the installed application.
 *
 * @this {import('../adb.js').ADB}
 * @param {string} pkg - The name of the installed package.
 * @return {Promise<import('./types').AppInfo>} The parsed application information.
 */
export function getPackageInfo(this: import("../adb.js").ADB, pkg: string): Promise<import("./types").AppInfo>;
/**
 * Fetches base.apk of the given package to the local file system
 *
 * @this {import('../adb.js').ADB}
 * @param {string} pkg The package identifier (must be already installed on the device)
 * @param {string} tmpDir The destination folder path
 * @returns {Promise<string>} Full path to the downloaded file
 * @throws {Error} If there was an error while fetching the .apk
 */
export function pullApk(this: import("../adb.js").ADB, pkg: string, tmpDir: string): Promise<string>;
/**
 * Activates the given application or launches it if necessary.
 * The action literally simulates
 * clicking the corresponding application icon on the dashboard.
 *
 * @this {import('../adb.js').ADB}
 * @param {string} appId - Application package identifier
 * @throws {Error} If the app cannot be activated
 */
export function activateApp(this: import("../adb.js").ADB, appId: string): Promise<void>;
/** @type {import('./types').StringRecord<import('./types').InstallState>} */
export const APP_INSTALL_STATE: import("./types").StringRecord<import("./types").InstallState>;
export const REMOTE_CACHE_ROOT: "/data/local/tmp/appium_cache";
import { LRUCache } from 'lru-cache';
//# sourceMappingURL=apk-utils.d.ts.map