/**
 * Creates chunks for the given arguments and executes them in `adb shell`.
 * This is faster than calling `adb shell` separately for each arg, however
 * there is a limit for a maximum length of a single adb command. that is why
 * we need all this complicated logic.
 *
 * @this {import('../adb.js').ADB}
 * @param {(x: string) => string[]} argTransformer A function, that receives single argument
 * from the `args` array and transforms it into a shell command. The result
 * of the function must be an array, where each item is a part of a single command.
 * The last item of the array could be ';'. If this is not a semicolon then it is going to
 * be added automatically.
 * @param {string[]} args Array of argument values to create chunks for
 * @throws {Error} If any of the chunks returns non-zero exit code after being executed
 */
export function shellChunks(this: import("../adb.js").ADB, argTransformer: (x: string) => string[], args: string[]): Promise<void>;
/**
 * Get the path to adb executable amd assign it
 * to this.executable.path and this.binaries.adb properties.
 *
 * @this {import('../adb.js').ADB}
 * @return {Promise<import('../adb.js').ADB>} ADB instance.
 */
export function getAdbWithCorrectAdbPath(this: import("../adb.js").ADB): Promise<import("../adb.js").ADB>;
/**
 * Get the full path to aapt tool and assign it to
 * this.binaries.aapt property
 * @this {import('../adb.js').ADB}
 */
export function initAapt(this: import("../adb.js").ADB): Promise<void>;
/**
 * Get the full path to aapt2 tool and assign it to
 * this.binaries.aapt2 property
 * @this {import('../adb.js').ADB}
 */
export function initAapt2(this: import("../adb.js").ADB): Promise<void>;
/**
 * Get the full path to zipalign tool and assign it to
 * this.binaries.zipalign property
 * @this {import('../adb.js').ADB}
 */
export function initZipAlign(this: import("../adb.js").ADB): Promise<void>;
/**
 * Get the full path to bundletool binary and assign it to
 * this.binaries.bundletool property
 * @this {import('../adb.js').ADB}
 */
export function initBundletool(this: import("../adb.js").ADB): Promise<void>;
/**
 * Retrieve the API level of the device under test.
 *
 * @this {import('../adb.js').ADB}
 * @return {Promise<number>} The API level as integer number, for example 21 for
 *                  Android Lollipop. The result of this method is cached, so all the further
 * calls return the same value as the first one.
 */
export function getApiLevel(this: import("../adb.js").ADB): Promise<number>;
export class getApiLevel {
    _apiLevel: number | undefined;
}
/**
 * Verify whether a device is connected.
 *
 * @this {import('../adb.js').ADB}
 * @return {Promise<boolean>} True if at least one device is visible to adb.
 */
export function isDeviceConnected(this: import("../adb.js").ADB): Promise<boolean>;
/**
 * Recursively create a new folder on the device under test.
 *
 * @this {import('../adb.js').ADB}
 * @param {string} remotePath - The new path to be created.
 * @return {Promise<string>} mkdir command output.
 */
export function mkdir(this: import("../adb.js").ADB, remotePath: string): Promise<string>;
/**
 * Verify whether the given argument is a
 * valid class name.
 *
 * @this {import('../adb.js').ADB}
 * @param {string} classString - The actual class name to be verified.
 * @return {boolean} The result of Regexp.exec operation
 * or _null_ if no matches are found.
 */
export function isValidClass(this: import("../adb.js").ADB, classString: string): boolean;
/**
 * Fetches the fully qualified name of the launchable activity for the
 * given package. It is expected the package is already installed on
 * the device under test.
 *
 * @this {import('../adb.js').ADB}
 * @param {string} pkg - The target package identifier
 * @param {import('./types').ResolveActivityOptions} opts
 * @return {Promise<string>} Fully qualified name of the launchable activity
 * @throws {Error} If there was an error while resolving the activity name
 */
export function resolveLaunchableActivity(this: import("../adb.js").ADB, pkg: string, opts?: import("./types").ResolveActivityOptions): Promise<string>;
/**
 * Force application to stop on the device under test.
 *
 * @this {import('../adb.js').ADB}
 * @param {string} pkg - The package name to be stopped.
 * @return {Promise<string>} The output of the corresponding adb command.
 */
export function forceStop(this: import("../adb.js").ADB, pkg: string): Promise<string>;
/**
 * Kill application
 *
 * @this {import('../adb.js').ADB}
 * @param {string} pkg - The package name to be stopped.
 * @return {Promise<string>} The output of the corresponding adb command.
 */
export function killPackage(this: import("../adb.js").ADB, pkg: string): Promise<string>;
/**
 * Clear the user data of the particular application on the device
 * under test.
 *
 * @this {import('../adb.js').ADB}
 * @param {string} pkg - The package name to be cleared.
 * @return {Promise<string>} The output of the corresponding adb command.
 */
export function clear(this: import("../adb.js").ADB, pkg: string): Promise<string>;
/**
 * Grant all permissions requested by the particular package.
 * This method is only useful on Android 6.0+ and for applications
 * that support components-based permissions setting.
 *
 * @this {import('../adb.js').ADB}
 * @param {string} pkg - The package name to be processed.
 * @param {string} [apk] - The path to the actual apk file.
 * @throws {Error} If there was an error while granting permissions
 */
export function grantAllPermissions(this: import("../adb.js").ADB, pkg: string, apk?: string): Promise<void>;
/**
 * Grant multiple permissions for the particular package.
 * This call is more performant than `grantPermission` one, since it combines
 * multiple `adb shell` calls into a single command.
 *
 * @this {import('../adb.js').ADB}
 * @param {string} pkg - The package name to be processed.
 * @param {Array<string>} permissions - The list of permissions to be granted.
 * @throws {Error} If there was an error while changing permissions.
 */
export function grantPermissions(this: import("../adb.js").ADB, pkg: string, permissions: Array<string>): Promise<void>;
/**
 * Grant single permission for the particular package.
 *
 * @this {import('../adb.js').ADB}
 * @param {string} pkg - The package name to be processed.
 * @param {string} permission - The full name of the permission to be granted.
 * @throws {Error} If there was an error while changing permissions.
 */
export function grantPermission(this: import("../adb.js").ADB, pkg: string, permission: string): Promise<void>;
/**
 * Revoke single permission from the particular package.
 *
 * @this {import('../adb.js').ADB}
 * @param {string} pkg - The package name to be processed.
 * @param {string} permission - The full name of the permission to be revoked.
 * @throws {Error} If there was an error while changing permissions.
 */
export function revokePermission(this: import("../adb.js").ADB, pkg: string, permission: string): Promise<void>;
/**
 * Retrieve the list of granted permissions for the particular package.
 *
 * @this {import('../adb.js').ADB}
 * @param {string} pkg - The package name to be processed.
 * @param {string?} [cmdOutput=null] - Optional parameter containing command output of
 * _dumpsys package_ command. It may speed up the method execution.
 * @return {Promise<string[]>} The list of granted permissions or an empty list.
 * @throws {Error} If there was an error while changing permissions.
 */
export function getGrantedPermissions(this: import("../adb.js").ADB, pkg: string, cmdOutput?: string | null): Promise<string[]>;
/**
 * Retrieve the list of denied permissions for the particular package.
 *
 * @this {import('../adb.js').ADB}
 * @param {string} pkg - The package name to be processed.
 * @param {string?} [cmdOutput=null] - Optional parameter containing command output of
 * _dumpsys package_ command. It may speed up the method execution.
 * @return {Promise<string[]>} The list of denied permissions or an empty list.
 */
export function getDeniedPermissions(this: import("../adb.js").ADB, pkg: string, cmdOutput?: string | null): Promise<string[]>;
/**
 * Retrieve the list of requested permissions for the particular package.
 *
 * @this {import('../adb.js').ADB}
 * @param {string} pkg - The package name to be processed.
 * @param {string?} [cmdOutput=null] - Optional parameter containing command output of
 *                                    _dumpsys package_ command. It may speed up the method execution.
 * @return {Promise<string[]>} The list of requested permissions or an empty list.
 */
export function getReqPermissions(this: import("../adb.js").ADB, pkg: string, cmdOutput?: string | null): Promise<string[]>;
/**
 * Stop the particular package if it is running and clears its application data.
 *
 * @this {import('../adb.js').ADB}
 * @param {string} pkg - The package name to be processed.
 */
export function stopAndClear(this: import("../adb.js").ADB, pkg: string): Promise<void>;
/**
 * Clear the active text field on the device under test by sending
 * special keyevents to it.
 *
 * @this {import('../adb.js').ADB}
 * @param {number} [length=100] - The maximum length of the text in the field to be cleared.
 */
export function clearTextField(this: import("../adb.js").ADB, length?: number): Promise<void>;
/**
 * Send the special keycode to the device under test in order to lock it.
 * @this {import('../adb.js').ADB}
 */
export function lock(this: import("../adb.js").ADB): Promise<void>;
/**
 * Send the special keycode to the device under test in order to emulate
 * Back button tap.
 * @this {import('../adb.js').ADB}
 */
export function back(this: import("../adb.js").ADB): Promise<void>;
/**
 * Send the special keycode to the device under test in order to emulate
 * Home button tap.
 * @this {import('../adb.js').ADB}
 */
export function goToHome(this: import("../adb.js").ADB): Promise<void>;
/**
 * @this {import('../adb.js').ADB}
 * @return {string} the actual path to adb executable.
 */
export function getAdbPath(this: import("../adb.js").ADB): string;
/**
 * Send an arbitrary Telnet command to the device under test.
 *
 * @this {import('../adb.js').ADB}
 * @param {string} command - The command to be sent.
 * @return {Promise<string>} The actual output of the given command.
 */
export function sendTelnetCommand(this: import("../adb.js").ADB, command: string): Promise<string>;
/**
 * Forcefully recursively remove a path on the device under test.
 * Be careful while calling this method.
 *
 * @this {import('../adb.js').ADB}
 * @param {string} path - The path to be removed recursively.
 */
export function rimraf(this: import("../adb.js").ADB, path: string): Promise<void>;
/**
 * Send a file to the device under test.
 *
 * @this {import('../adb.js').ADB}
 * @param {string} localPath - The path to the file on the local file system.
 * @param {string} remotePath - The destination path on the remote device.
 * @param {object} [opts] - Additional options mapping. See
 *                        https://github.com/appium/node-teen_process,
 *                        _exec_ method options, for more information about available
 *                        options.
 */
export function push(this: import("../adb.js").ADB, localPath: string, remotePath: string, opts?: object): Promise<void>;
/**
 * Receive a file from the device under test.
 *
 * @this {import('../adb.js').ADB}
 * @param {string} remotePath - The source path on the remote device.
 * @param {string} localPath - The destination path to the file on the local file system.
 * @param {import('teen_process').TeenProcessExecOptions} [opts={}] - Additional options mapping. See
 * https://github.com/appium/node-teen_process,
 * _exec_ method options, for more information about available
 * options.
 */
export function pull(this: import("../adb.js").ADB, remotePath: string, localPath: string, opts?: import("teen_process").TeenProcessExecOptions): Promise<void>;
/**
 * Check whether the process with the particular name is running on the device
 * under test.
 *
 * @this {import('../adb.js').ADB}
 * @param {string} processName - The name of the process to be checked.
 * @return {Promise<boolean>} True if the given process is running.
 * @throws {Error} If the given process name is not a valid class name.
 */
export function processExists(this: import("../adb.js").ADB, processName: string): Promise<boolean>;
/**
 * Get TCP port forwarding with adb on the device under test.
 *
 * @this {import('../adb.js').ADB}
 * @return {Promise<string[]>} The output of the corresponding adb command.
 * An array contains each forwarding line of output
 */
export function getForwardList(this: import("../adb.js").ADB): Promise<string[]>;
/**
 * Setup TCP port forwarding with adb on the device under test.
 *
 * @this {import('../adb.js').ADB}
 * @param {string|number} systemPort - The number of the local system port.
 * @param {string|number} devicePort - The number of the remote device port.
 */
export function forwardPort(this: import("../adb.js").ADB, systemPort: string | number, devicePort: string | number): Promise<void>;
/**
 * Remove TCP port forwarding with adb on the device under test. The forwarding
 * for the given port should be setup with {@link #forwardPort} first.
 *
 * @this {import('../adb.js').ADB}
 * @param {string|number} systemPort - The number of the local system port
 *                                     to remove forwarding on.
 */
export function removePortForward(this: import("../adb.js").ADB, systemPort: string | number): Promise<void>;
/**
 * Get TCP port forwarding with adb on the device under test.
 *
 * @this {import('../adb.js').ADB}
 * @return {Promise<string[]>} The output of the corresponding adb command.
 * An array contains each forwarding line of output
 */
export function getReverseList(this: import("../adb.js").ADB): Promise<string[]>;
/**
 * Setup TCP port forwarding with adb on the device under test.
 * Only available for API 21+.
 *
 * @this {import('../adb.js').ADB}
 * @param {string|number} devicePort - The number of the remote device port.
 * @param {string|number} systemPort - The number of the local system port.
 */
export function reversePort(this: import("../adb.js").ADB, devicePort: string | number, systemPort: string | number): Promise<void>;
/**
 * Remove TCP port forwarding with adb on the device under test. The forwarding
 * for the given port should be setup with {@link #forwardPort} first.
 *
 * @this {import('../adb.js').ADB}
 * @param {string|number} devicePort - The number of the remote device port
 *                                     to remove forwarding on.
 */
export function removePortReverse(this: import("../adb.js").ADB, devicePort: string | number): Promise<void>;
/**
 * Setup TCP port forwarding with adb on the device under test. The difference
 * between {@link #forwardPort} is that this method does setup for an abstract
 * local port.
 *
 * @this {import('../adb.js').ADB}
 * @param {string|number} systemPort - The number of the local system port.
 * @param {string|number} devicePort - The number of the remote device port.
 */
export function forwardAbstractPort(this: import("../adb.js").ADB, systemPort: string | number, devicePort: string | number): Promise<void>;
/**
 * Execute ping shell command on the device under test.
 *
 * @this {import('../adb.js').ADB}
 * @return {Promise<boolean>} True if the command output contains 'ping' substring.
 * @throws {Error} If there was an error while executing 'ping' command on the
 *                 device under test.
 */
export function ping(this: import("../adb.js").ADB): Promise<boolean>;
/**
 * Restart the device under test using adb commands.
 *
 * @this {import('../adb.js').ADB}
 * @throws {Error} If start fails.
 */
export function restart(this: import("../adb.js").ADB): Promise<void>;
/**
 * Start the logcat process to gather logs.
 *
 * @this {import('../adb.js').ADB}
 * @param {import('./types').LogcatOpts} [opts={}]
 * @throws {Error} If restart fails.
 */
export function startLogcat(this: import("../adb.js").ADB, opts?: import("./types").LogcatOpts): Promise<void>;
export class startLogcat {
    /**
     * Start the logcat process to gather logs.
     *
     * @this {import('../adb.js').ADB}
     * @param {import('./types').LogcatOpts} [opts={}]
     * @throws {Error} If restart fails.
     */
    constructor(this: import("../adb.js").ADB, opts?: import("./types").LogcatOpts);
    logcat: Logcat;
    _logcatStartupParams: import("./types").LogcatOpts;
}
/**
 * Stop the active logcat process which gathers logs.
 * The call will be ignored if no logcat process is running.
 * @this {import('../adb.js').ADB}
 */
export function stopLogcat(this: import("../adb.js").ADB): Promise<void>;
export class stopLogcat {
    logcat: any;
}
/**
 * Retrieve the output from the currently running logcat process.
 * The logcat process should be executed by {2link #startLogcat} method.
 *
 * @this {import('../adb.js').ADB}
 * @return {import('./types').LogEntry[]} The collected logcat output.
 * @throws {Error} If logcat process is not running.
 */
export function getLogcatLogs(this: import("../adb.js").ADB): import("./types").LogEntry[];
/**
 * Set the callback for the logcat output event.
 *
 * @this {import('../adb.js').ADB}
 * @param {import('./types').LogcatListener} listener - Listener function
 * @throws {Error} If logcat process is not running.
 */
export function setLogcatListener(this: import("../adb.js").ADB, listener: import("./types").LogcatListener): void;
/**
 * Removes the previously set callback for the logcat output event.
 *
 * @this {import('../adb.js').ADB}
 * @param {import('./types').LogcatListener} listener
 * The listener function, which has been previously
 * passed to `setLogcatListener`
 * @throws {Error} If logcat process is not running.
 */
export function removeLogcatListener(this: import("../adb.js").ADB, listener: import("./types").LogcatListener): void;
/**
 * At some point of time Google has changed the default `ps` behaviour, so it only
 * lists processes that belong to the current shell user rather to all
 * users. It is necessary to execute ps with -A command line argument
 * to mimic the previous behaviour.
 *
 * @this {import('../adb.js').ADB}
 * @returns {Promise<string>} the output of `ps` command where all processes are included
 */
export function listProcessStatus(this: import("../adb.js").ADB): Promise<string>;
export class listProcessStatus {
    _doesPsSupportAOption: boolean;
}
/**
 * Returns process name for the given process identifier
 *
 * @this {import('../adb.js').ADB}
 * @param {string|number} pid - The valid process identifier
 * @throws {Error} If the given PID is either invalid or is not present
 * in the active processes list
 * @returns {Promise<string>} The process name
 */
export function getNameByPid(this: import("../adb.js").ADB, pid: string | number): Promise<string>;
/**
 * Get the list of process ids for the particular process on the device under test.
 *
 * @this {import('../adb.js').ADB}
 * @param {string} name - The part of process name.
 * @return {Promise<number[]>} The list of matched process IDs or an empty list.
 * @throws {Error} If the passed process name is not a valid one
 */
export function getPIDsByName(this: import("../adb.js").ADB, name: string): Promise<number[]>;
export class getPIDsByName {
    /**
     * Get the list of process ids for the particular process on the device under test.
     *
     * @this {import('../adb.js').ADB}
     * @param {string} name - The part of process name.
     * @return {Promise<number[]>} The list of matched process IDs or an empty list.
     * @throws {Error} If the passed process name is not a valid one
     */
    constructor(this: import("../adb.js").ADB, name: string);
    _isPgrepAvailable: boolean | undefined;
    _canPgrepUseFullCmdLineSearch: boolean | undefined;
    _isPidofAvailable: boolean | undefined;
}
/**
 * Get the list of process ids for the particular process on the device under test.
 *
 * @this {import('../adb.js').ADB}
 * @param {string} name - The part of process name.
 */
export function killProcessesByName(this: import("../adb.js").ADB, name: string): Promise<void>;
/**
 * Kill the particular process on the device under test.
 * The current user is automatically switched to root if necessary in order
 * to properly kill the process.
 *
 * @this {import('../adb.js').ADB}
 * @param {string|number} pid - The ID of the process to be killed.
 * @throws {Error} If the process cannot be killed.
 */
export function killProcessByPID(this: import("../adb.js").ADB, pid: string | number): Promise<void>;
/**
 * Broadcast process killing on the device under test.
 *
 * @this {import('../adb.js').ADB}
 * @param {string} intent - The name of the intent to broadcast to.
 * @param {string} processName - The name of the killed process.
 * @throws {error} If the process was not killed.
 */
export function broadcastProcessEnd(this: import("../adb.js").ADB, intent: string, processName: string): Promise<void>;
/**
 * Broadcast a message to the given intent.
 *
 * @this {import('../adb.js').ADB}
 * @param {string} intent - The name of the intent to broadcast to.
 * @throws {error} If intent name is not a valid class name.
 */
export function broadcast(this: import("../adb.js").ADB, intent: string): Promise<void>;
/**
 * Retrieve the `adb bugreport` command output. This
 * operation may take up to several minutes.
 *
 * @this {import('../adb.js').ADB}
 * @param {number} [timeout=120000] - Command timeout in milliseconds
 * @returns {Promise<string>} Command stdout
 */
export function bugreport(this: import("../adb.js").ADB, timeout?: number): Promise<string>;
/**
 * Initiate screenrecord utility on the device
 *
 * @this {import('../adb.js').ADB}
 * @param {string} destination - Full path to the writable media file destination
 *                               on the device file system.
 * @param {import('./types').ScreenrecordOptions} [options={}]
 * @returns {SubProcess} screenrecord process, which can be then controlled by the client code
 */
export function screenrecord(this: import("../adb.js").ADB, destination: string, options?: import("./types").ScreenrecordOptions): SubProcess;
/**
 * Retrieves the list of features supported by the device under test
 *
 * @this {import('../adb.js').ADB}
 * @returns {Promise<string[]>} the list of supported feature names or an empty list.
 * An example adb command output:
 * ```
 * cmd
 * ls_v2
 * fixed_push_mkdir
 * shell_v2
 * abb
 * stat_v2
 * apex
 * abb_exec
 * remount_shell
 * fixed_push_symlink_timestamp
 * ```
 * @throws {Error} if there was an error while retrieving the list
 */
export function listFeatures(this: import("../adb.js").ADB): Promise<string[]>;
export class listFeatures {
    _memoizedFeatures: () => Promise<string>;
}
/**
 * Checks the state of streamed install feature.
 * This feature allows to speed up apk installation
 * since it does not require the original apk to be pushed to
 * the device under test first, which also saves space.
 * Although, it is required that both the device under test
 * and the adb server have the mentioned functionality.
 * See https://github.com/aosp-mirror/platform_system_core/blob/master/adb/client/adb_install.cpp
 * for more details
 *
 * @this {import('../adb.js').ADB}
 * @returns {Promise<boolean>} `true` if the feature is supported by both adb and the
 * device under test
 */
export function isStreamedInstallSupported(this: import("../adb.js").ADB): Promise<boolean>;
/**
 * Checks whether incremental install feature is supported by ADB.
 * Read https://developer.android.com/preview/features#incremental
 * for more details on it.
 *
 * @this {import('../adb.js').ADB}
 * @returns {Promise<boolean>} `true` if the feature is supported by both adb and the
 * device under test
 */
export function isIncrementalInstallSupported(this: import("../adb.js").ADB): Promise<boolean>;
/**
 * Takes a screenshot of the given display or the default display.
 *
 * @this {import('../adb.js').ADB}
 * @param {number|string?} displayId A valid display identifier. If
 * no identifier is provided then the screenshot of the default display is returned.
 * Note that only recent Android APIs provide multi-screen support.
 * @returns {Promise<Buffer>} PNG screenshot payload
 */
export function takeScreenshot(this: import("../adb.js").ADB, displayId: number | (string | null)): Promise<Buffer>;
/**
 * Returns the list of TCP port states of the given family.
 * Could be empty if no ports are opened.
 *
 * @this {import('../adb.js').ADB}
 * @param {import('./types').PortFamily} [family='4']
 * @returns {Promise<import('./types').PortInfo[]>}
 */
export function listPorts(this: import("../adb.js").ADB, family?: import("./types").PortFamily): Promise<import("./types").PortInfo[]>;
import { Logcat } from '../logcat';
import { SubProcess } from 'teen_process';
//# sourceMappingURL=adb-commands.d.ts.map